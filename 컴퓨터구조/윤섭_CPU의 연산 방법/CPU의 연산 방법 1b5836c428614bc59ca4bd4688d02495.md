# CPU의 연산 방법

## CPU의 연산 방법

                                                                                                                                                 23/06/11

📎 덧셈

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%201b5836c428614bc59ca4bd4688d02495/Untitled.png)

- 덧셈을 하기 위해 필요한 파라미터는 연산할 숫자 A와 B, 자리올림이 되는지 판단해줄 C 총 3개이다.
- 자리올림(carrying), 자리내림(borrowing)의 경우 전가산기를 통해 저장되고 더해진다.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%201b5836c428614bc59ca4bd4688d02495/Untitled%201.png)

<aside>
💡 전가산기란 이진 회로의 덧셈을 연산하는 디지털 회로이다.

</aside>

- 4bit의 덧셈을 수행하기 위해서는 위와 같이 4개의 전가산기(Full Adder)가 필요하고, 각 연산을 수행한 결과는 다음 자리수의 input으로 들어가게 된다.

```jsx
a = 3;
b = 2;
a + b = 5

    1  -> carrying
  0 0 1 1 -> 3
+ 0 0 1 0 -> 2
----------
  0 1 0 1 -> 5
```

📎 덧셈

- 직접적인 뺄셈의 수행할 수 없기 때문에 보수(Complement)를 이용해 덧셈으로 계산한다.
- 보수는 수를 반전시킨 후 1을 더하면 된다.
- 10진수 2
    - 2진수로 변환하면 0 0 1 0
    - 반전시키면 1 1 0 1
    - 1을 더하면 1 1 1 0

```
a = 3
b = 2
a - b = 1

2의 보수
0 0 1 0(b)  ->   1 1 0 1 (~b)  ->   0 0 1 1  (a)
               + 0 0 0 1 (+1)     + 1 1 1 0  (b의 보수)
							  ----------         ---------
                 1 1 1 0            0 0 0 1  -> 결과 1
```

📎 곱셈

- 곱셈은 가산기(adder)와 계수기(counter)를 통해 기본적인 원리로 구현한다. 피승수(곱해지는 수)를 승수(곱하는 수) 횟수만큼 더하는 것이다.

```
a = 3
b = 2

a + a (b 만큼 더함)
3 + 3 == 6
```

- 간단한 승수 및 피승수를 곱하는 경우에는 이 방법을 쉽게 사용할 수 있으나, 32bit 이상 큰 수를 곱할 경우 2의 32제곱(4,294,967,296)회까지 덧셈을 수행해야 할 수도 있다. 이러한 수의 계산은 비현실적이기에 Shifter를 사용한다.

```
 0 1 0 1 (3)

 1 0 1 0 (6) << 왼쪽으로 한 칸씩 이동, 오른쪽에는 0이 채워진다. (Padding)

 왼쪽으로 한칸 밀면 곱하기 2, 두 칸 밀면 곱하기 4가 된다.
```

📎 나눗셈

- 나눗셈은 몫이 제수(나누는 수) 미만이 될 때까지 피제수(나누어지는 수)에서 제수를 앞서 설명했던 뺄셈을 통해 구현한다.

```
a = 9
b = 3

9 - 3 == 6 >= 3 -> true
6 - 3 == 3 >= 3 -> true
3 - 3 == 0 >= 3 -> false

뺄셈 횟수(몫) == 3
최종 연산 결과(나머지) == 0
```

- 만약 0으로 나누게 되면 어떤 결과가 발생할까?

```
a = 5
b = 0

5 - 0 == 5 >= 0 -> true
5 - 0 == 5 >= 0 -> true

무한 루프 발생
```

- 이러한 이유 때문에 ArithmeticException: / by zero와 같은 예외가 발생하는 것이다.
- 나눗셈도 곱셈과 동일하게 큰 수를 연산할 경우 Shifter를 사용한다.